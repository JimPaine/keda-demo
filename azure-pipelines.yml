stages:

- stage: ProvisionEnvironment
  variables:
    - group: 'Terraform Service Principal'
    - group: 'Terraform State'
    - name: tfstate_key
      value: 'jimpaine.keda-demo.master.tfstate'
    - name: resource_name
      value: 'keda'

  jobs:
  - job: TransformConfiguration
    pool:      
      vmImage: 'Ubuntu-16.04'
    steps:
    - task: qetza.replacetokens.replacetokens-task.replacetokens@3
      displayName: 'Replace tokens in **/*.tfvars'

      inputs:
        rootDirectory: ./env
        targetFiles: '**/*.tfvars'

    - task: HelmInstaller@0
      displayName: 'Install Helm 2.9.1'

    - script: helm repo add kedacore https://kedacore.azureedge.net/helm    
      workingDirectory: ./env
      displayName: 'helm add keda repo'
    
    - script: helm repo add osiris https://osiris.azurecr.io/helm/v1/repo --username eae9749a-fccf-4a24-ac0d-6506fe2a6ab3 --password 2fc6a721-85e4-41ca-933d-2ca02e1394c4    
      workingDirectory: ./env
      displayName: 'helm add osiris repo'
      
    
    - script: helm repo update    
      workingDirectory: ./env
      displayName: 'helm repo update'
  
    - script: |
        terraform init \
          -backend-config="resource_group_name=$(tfstate_resource_group)" \
          -backend-config="storage_account_name=$(tfstate_storage_account)" \
          -backend-config="container_name=$(tfstate_container)" \
          -backend-config="key=$(tfstate_key)" \
          -backend-config="access_key=$(tfstate_access_key)"

      workingDirectory: ./env
      displayName: 'Terraform init'

    - script: terraform apply -auto-approve
      workingDirectory: ./env
      displayName: 'Terraform apply'
  
- stage: BuildAndPush
  jobs:
    - job: HttpFunction
      variables:
        - group: 'Terraform Service Principal'
        - group: 'Terraform State'
        - name: tfstate_key
          value: 'jimpaine.keda-demo.master.tfstate'
        - name: resource_name
          value: 'keda'
        - name: acr_server
          value: 'placeholder'
        - name: acr_password
          value: 'placeholder'
        - name: acr_user
          value: 'placeholder'
      pool:      
        vmImage: 'Ubuntu-16.04'
      steps:
      - script: wget https://github.com/Azure/azure-functions-core-tools/releases/download/2.7.1158/Azure.Functions.Cli.linux-x64.2.7.1158.zip
        displayName: 'download func cli'
        workingDirectory: ./functions/http
      - script: unzip Azure.Functions.Cli.linux-x64.2.7.1158.zip
        displayName: 'unzip func cli'
        workingDirectory: ./functions/http
      - script: chmod +x func
        displayName: 'make func executable'
        workingDirectory: ./functions/http
      - script: ./func init --docker-only --worker-runtime dotnet
        displayName: 'Dockerise func'
        workingDirectory: ./functions/http
      - script: |
          terraform init \
            -backend-config="resource_group_name=$(tfstate_resource_group)" \
            -backend-config="storage_account_name=$(tfstate_storage_account)" \
            -backend-config="container_name=$(tfstate_container)" \
            -backend-config="key=$(tfstate_key)" \
            -backend-config="access_key=$(tfstate_access_key)"
  
        workingDirectory: ./env
        displayName: 'Terraform init'
      - script: |
          acr_server=$(terraform output -json acr_server | jq '.value' | tr -d '"')   
          echo "##vso[task.setvariable variable=acr_server;]$acr_server"

          acr_password=$(terraform output -json acr_password | jq '.value' | tr -d '"')   
          echo "##vso[task.setvariable variable=acr_password;]$acr_password"

          acr_user=$(terraform output -json acr_user | jq '.value' | tr -d '"')   
          echo "##vso[task.setvariable variable=acr_user;]$acr_user"
  
        workingDirectory: ./env
        displayName: 'Get ACR details'
      - script: docker login -u $(acr_user) -p $(acr_password) $(acr_server)
        displayName: 'docker login'
      - script: docker build './functions/http' -t $(acr_server)/http:$(Build.BuildId)
        displayName: 'docker build'
      - script: docker push $(acr_server)/http:$(Build.BuildId)
        displayName: 'docker push'
      - script: ./func kubernetes deploy --name http --image-name $(acr_server)/http:$(Build.BuildId) --pull-secret registry --dry-run --csharp > deployment.yaml
        displayName: 'Generate k8s deployment'
        workingDirectory: ./functions/http
      - task: PublishPipelineArtifact@0
        inputs:
          artifactName: 'http' 
          targetPath: './functions/http/deployment.yaml'
    
    - job: QueueFunction
      variables:
        - group: 'Terraform Service Principal'
        - group: 'Terraform State'
        - name: tfstate_key
          value: 'jimpaine.keda-demo.master.tfstate'
        - name: resource_name
          value: 'keda'
        - name: acr_server
          value: 'placeholder'
        - name: acr_password
          value: 'placeholder'
        - name: acr_user
          value: 'placeholder'
      pool:      
        vmImage: 'Ubuntu-16.04'
      steps:
      - script: wget https://github.com/Azure/azure-functions-core-tools/releases/download/2.7.1158/Azure.Functions.Cli.linux-x64.2.7.1158.zip
        displayName: 'download func cli'
        workingDirectory: ./functions/queue
      - script: unzip Azure.Functions.Cli.linux-x64.2.7.1158.zip
        displayName: 'unzip func cli'
        workingDirectory: ./functions/queue
      - script: chmod +x func
        displayName: 'make func executable'
        workingDirectory: ./functions/queue

      - script: |
          terraform init \
            -backend-config="resource_group_name=$(tfstate_resource_group)" \
            -backend-config="storage_account_name=$(tfstate_storage_account)" \
            -backend-config="container_name=$(tfstate_container)" \
            -backend-config="key=$(tfstate_key)" \
            -backend-config="access_key=$(tfstate_access_key)"
  
        workingDirectory: ./env
        displayName: 'Terraform init'

      - script: |
          acr_server=$(terraform output -json acr_server | jq '.value' | tr -d '"')   
          echo "##vso[task.setvariable variable=acr_server;]$acr_server"

          acr_password=$(terraform output -json acr_password | jq '.value' | tr -d '"')   
          echo "##vso[task.setvariable variable=acr_password;]$acr_password"

          acr_user=$(terraform output -json acr_user | jq '.value' | tr -d '"')   
          echo "##vso[task.setvariable variable=acr_user;]$acr_user"

          queue-connection-string=$(terraform output -json queue-connection-string | jq '.value' | tr -d '"')   
          echo "##vso[task.setvariable variable=queue-connection-string;]$queue-connection-string"
  
        workingDirectory: ./env
        displayName: 'Get environment details'

      - task: qetza.replacetokens.replacetokens-task.replacetokens@3
        displayName: 'Replace tokens in **/*.tfvars'
  
        inputs:
          rootDirectory: ./functions/queue
          targetFiles: '**/local.settings.json'

      - script: ./func init --docker-only --worker-runtime dotnet
        displayName: 'Dockerise func'
        workingDirectory: ./functions/queue
      
      - script: docker login -u $(acr_user) -p $(acr_password) $(acr_server)
        displayName: 'docker login'
      - script: docker build './functions/queue' -t $(acr_server)/queue:$(Build.BuildId)
        displayName: 'docker build'
      - script: docker push $(acr_server)/queue:$(Build.BuildId)
        displayName: 'docker push'
      - script: ./func kubernetes deploy --name queue --image-name $(acr_server)/queue:$(Build.BuildId) --pull-secret registry --dry-run --csharp > deployment.yaml
        displayName: 'Generate k8s deployment'
        workingDirectory: ./functions/queue
      - task: PublishPipelineArtifact@0
        inputs:
          artifactName: 'queue' 
          targetPath: './functions/queue/deployment.yaml'

- stage: Deploy
  jobs:
    - job: HttpFunction
      variables:
        - group: 'Terraform Service Principal'
        - group: 'Terraform State'
        - name: tfstate_key
          value: 'jimpaine.keda-demo.master.tfstate'
        - name: resource_name
          value: 'keda'
      pool:      
        vmImage: 'Ubuntu-16.04'
      steps:
      - script: |
          terraform init \
            -backend-config="resource_group_name=$(tfstate_resource_group)" \
            -backend-config="storage_account_name=$(tfstate_storage_account)" \
            -backend-config="container_name=$(tfstate_container)" \
            -backend-config="key=$(tfstate_key)" \
            -backend-config="access_key=$(tfstate_access_key)"
  
        workingDirectory: ./env
        displayName: 'Terraform init'
      - script: |
          kubeconfig=$(terraform output -json kubeconfig | jq '.value' | tr -d '"')
          mkdir ~/.kube/
          touch ~/.kube/config
          echo -e "$kubeconfig" > ~/.kube/config
  
        workingDirectory: ./env
        displayName: 'Get kubeconfig'
      - task: DownloadPipelineArtifact@1
        inputs:
          buildType: current
          artifactName: http
          downloadPath: '$(System.ArtifactsDirectory)'
      - script: kubectl apply -f deployment.yaml
        displayName: 'kubectl apply -f deployment.yaml'
        workingDirectory: '$(System.ArtifactsDirectory)'

    - job: QueueFunction
      variables:
        - group: 'Terraform Service Principal'
        - group: 'Terraform State'
        - name: tfstate_key
          value: 'jimpaine.keda-demo.master.tfstate'
        - name: resource_name
          value: 'keda'
      pool:      
        vmImage: 'Ubuntu-16.04'
      steps:
      - script: |
          terraform init \
            -backend-config="resource_group_name=$(tfstate_resource_group)" \
            -backend-config="storage_account_name=$(tfstate_storage_account)" \
            -backend-config="container_name=$(tfstate_container)" \
            -backend-config="key=$(tfstate_key)" \
            -backend-config="access_key=$(tfstate_access_key)"
  
        workingDirectory: ./env
        displayName: 'Terraform init'
      - script: |
          kubeconfig=$(terraform output -json kubeconfig | jq '.value' | tr -d '"')
          mkdir ~/.kube/
          touch ~/.kube/config
          echo -e "$kubeconfig" > ~/.kube/config
  
        workingDirectory: ./env
        displayName: 'Get kubeconfig'
      - task: DownloadPipelineArtifact@1
        inputs:
          buildType: current
          artifactName: queue
          downloadPath: '$(System.ArtifactsDirectory)'
      - script: kubectl apply -f deployment.yaml
        displayName: 'kubectl apply -f deployment.yaml'
        workingDirectory: '$(System.ArtifactsDirectory)'
